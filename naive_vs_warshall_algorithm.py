# -*- coding: utf-8 -*-
"""Naive_Vs_Warshall_Algorithm.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1leq6_SwKziEtiEyamUCk73GS88cquvcs
"""

#defining meet function
def meet (a,b):
    if a!=0:a = 1
    if b!=0:b=1 
        
        
    if a==1 and b==1:
        return 1
    else:
        return 0

#Defining Join function
def join (a,b):
    if a!=0:a = 1
    
    if b!=0:b=1
        
    if a==1 or b==1:
        return 1
    else:
        return 0

#Defining Boolean Multiplication   
def boolMult(A,B):
    rowA = len(A)
    colA = len(A[0])
    rowB = len(B)
    colB = len(B[0])
    C = np.zeros([rowA,colB])
    for i in range (0,rowA):
        for j in range(0,colA):
            for k in range(0,rowB):
                C[i][j] = join(C[i][j], meet(A[i][k],B[k][j]))
    return C
 
#Defining function to join matricex 
def MatJoin(A,B):
    
    rowA = len(A)
    colA = len(A[0])
    rowB = len(B)
    colB = len(B[0])
    
    C = np.zeros([rowA,colB],dtype="int")
    
    for i in range (0,rowA,1):
        for j in range(0,colB):
            C[i][j] = join(A[i][j],B[i][j])
    
    return C
 
#Defining Naive Algorithm:
def Naive(A):
    
    result = A
    
    for i in range (2,len(A)+1,1):
        
        
        result = MatJoin(result,boolMult(result,A))
        
    return result
# Defining Warshall's Algorithm
def warshall(D):
    result = D
    
    for k in range(0,len(D),1):
        
        for i in range(0,len(D)):
            for j in range (0,len(D)):
                temp = result
                result[i][j] = join(result[i][j],meet(result[i][k],result[k][j]))
                
    
    return result

 
# Random Matrix Generator
 
import numpy as np
import random
 
def MatGen(n,weight=None):
    list1 = [0, 1]
    weight = random.randint(20,30)
    matrix = np.array([random.choices(list1, weights = (100 - weight, weight), k = n) for x in range(n)])
    return matrix
 
 
 
 
#Program for comparing both Algorithms
 
def algocomparison(Matrix_Size1=10,Matrix_Size2=100):
    import time
    import math
    
    timecomparison = []
    
    print("================================================================")
    print("                       Program Initiated                        ")
    print("================================================================")
      
    for i in range (Matrix_Size1,Matrix_Size2+1,1):
        matrix = MatGen(i)
        #matrix = np.random.randint(2,size = (i,i), dtype = 'int')
        #matrix = np.array([[1,0,0,1],[0,1,1,0],[0,0,0,1],[0,0,0,0]])
        
        
        #print("\n===========Matrix Size======="+str(i)+"X"+str(i)+"\n")
        
        startN  = time.perf_counter()
        A = Naive(matrix)
        endN = time.perf_counter()
        t1 = (endN - startN)
        
        
        #print("\n======Naive Algorithm Time:"+str(t1)+" Nano sec=========\n")
        #print(A)
        #print("\n========================================================\n")
        
        
        
      
        
        startW  = time.perf_counter()
        B = warshall(matrix)
        endW = time.perf_counter()
        t2 = (endW - startW)
        
       
        #print("\n======>Warshall's Algorithm Time:"+str(t2)+" Nano sec<=======\n")
        #print(B)
        #print("\n================================================================\n")
        
        
        
 
        timecomparison.append([i,t1,t2])
        
        
        #print("======================================================")
    
    
    print("==================Program Run Successful==================")
    
    return timecomparison
    
 
 
# Output Generation
 
a = algocomparison()
 
b = np.array(a)
print("Output:")
print("Matrix_Size"+"\tNaive"+"\tWarshall's")
print(b)
    
# Plotting the data
import math
 
 
x= []
Tn = []
Tw = []
for i in range(0,91,1):
    x.append(b[i][0])
    Tn.append(b[i][1])
    Tw.append(b[i][2])
import matplotlib.pyplot as plt 
 
print("Plotting Naive Algorithm Output on Normal Decimal Scale:")
plt.scatter(x, Tn) 
plt.xlabel('Size of matrix') 
plt.ylabel('time taken by Naive in Sec') 
plt.title('naive Algorithm') 
plt.legend('Naive')
plt.show()
 
print("\nPlotting Warshall's Algorithm Output on Normal Decimal Scale:")
plt.scatter(x, Tw)
plt.xlabel('Size of matrix') 
plt.ylabel('time taken by Warshall in Sec') 
plt.title('Warshall Algorithm') 
plt.legend("Warshall")
plt.show() 
print("\nComparing Naive and  Warshall's Algorithm on Decimal Scale:")  
plt.scatter(x, Tw) 
plt.scatter(x, Tn) 
plt.xlabel('Size of matrix') 
plt.ylabel('time taken by in sec') 
plt.title("Naive Vs Warshall's Algorithm") 
plt.legend(["warshall","Naive"]) 
plt.show() 
 

print("\nOUTPUT ON LOGLOG (base10) SCALE:")
print("\nPlotting Naive Algorithm Output on loglog Scale:") 
plt.loglog(x, Tn) 
plt.xlabel('Size of matrix') 
plt.ylabel('time taken by Naive in Sec') 
plt.title('Naive Algorithm') 
plt.legend('Naive')
plt.show() 
print("\nPlotting Warshall's Algorithm Output on loglog Scale:") 
plt.loglog(x, Tw) 
plt.xlabel('Size of matrix') 
plt.ylabel('time taken by Warshall in Sec') 
plt.title('Warshall Algorithm') 
plt.legend("Warshall")
plt.show() 
# Comparing Naive and Warshall's Algorithm:
print("\nComparing Naive and  Warshall's Algorithm on loglog Scale:")  
plt.loglog(x, Tw) 
plt.loglog(x, Tn) 
plt.xlabel('Size of matrix') 
plt.ylabel('time taken by in sec') 
plt.title("Naive Vs Warshall's Algorithm") 
plt.legend(["warshall","Naive"]) 
plt.show() 

print("\nOUTPUT ON Natural LOGLOG (base 'e') SCALE:")
print("\nPlotting Naive Algorithm Output on Natural loglog Scale:") 
plt.loglog(x, Tn, basex = np.e, basey=np.e) 
plt.xlabel('Size of matrix') 
plt.ylabel('time taken by Naive in Sec') 
plt.title('naive Algorithm') 
plt.legend('Naive')
plt.show() 


print("\nPlotting Warshall's Algorithm Output on Natural loglog Scale:") 
plt.loglog(x, Tw, basex=np.e,basey=np.e) 
plt.xlabel('Size of matrix') 
plt.ylabel('time taken by Warshall in Sec') 
plt.title('Warshall Algorithm') 
plt.legend("Warshall")
plt.show() 
# Comparing Naive and Warshall's Algorithm:
print("\nComparing Naive and  Warshall's Algorithm on Natural loglog Scale:")  
plt.loglog(x, Tw, basex=np.e,basey=np.e) 
plt.loglog(x, Tn,basex=np.e,basey=np.e) 
plt.xlabel('Size of matrix') 
plt.ylabel('time taken by in sec') 
plt.title("Naive Vs Warshall's Algorithm") 
plt.legend(["warshall","Naive"]) 
plt.show() 
 
# Finding Order of the Algorithms:
 
import pandas as pd
data = pd.DataFrame([x,Tw,Tn,n,n2,n3,n4], index = ['x','Tw','Tn','n','n2','n3','n4']).T
from sklearn.linear_model import LinearRegression
data_log = np.log(data)
X = data_log['x'].values.reshape(-1,1)
T_w = data_log['Tw'].values.reshape(-1,1)
T_n = data_log['Tn'].values.reshape(-1,1)
# Doing Linear Regression for finding slope of the log log curve 
regressionTn = LinearRegression()
regressionTn.fit(X, T_n)
print("\nOrder of Naive Algorithm:")
print(regressionTn.coef_)
 
regressionTw = LinearRegression()
regressionTw.fit(X, T_w)
print("\nOrder of Warshall's Algorithm:")
print(regressionTw.coef_)

